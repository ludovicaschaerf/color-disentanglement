#!/usr/bin/env python

### srun --pty -n 1 -c 2 --time=01:00:00 --mem=64G bash -l

import argparse
import pandas as pd
import pickle
from tqdm import tqdm
import numpy as np
import sys
import matplotlib.pyplot as plt
from skimage.transform import resize
import os
from os.path import join
import seaborn as sns
from numpy.linalg import norm

sys.path.append('../annotations/')
from color_utils import rgb_to_hsv

DATA_DIR = '../data/'
from rescoring import ReScoring

# Creating a color map
with open(DATA_DIR + 'quantized_colors_and_names.pkl', 'rb') as infile:
    colors_dict = pickle.load(infile) 

COLOR_MAP = {k:tuple(v) for k,v in zip(colors_dict['names'], colors_dict['RGB'])}


class AttributeDependency(ReScoring):
    def __init__(self, model, annotations, space, compute_s=False, variable='color', categorical=True, repo_folder='.'):
        super().__init__(model, annotations, space, compute_s, variable, categorical, repo_folder)
    
    def plot_hues_per_lambda(self, variations, feature, method, variable='Color'):
        variations = variations[variations['Feature'] == feature]
        for lambd, group in variations.groupby('lambda'):
            color_hues = list(group['H1'])
            hue_wheel_image = plt.imread(DATA_DIR + 'Linear_RGB_color_wheel.png')
            hue_wheel_image = resize(hue_wheel_image, (256,256))
            # Display the hue wheel image
            fig, ax = plt.subplots(dpi=80)
            ax.set_title(f'Color distribution of {feature} at lambda {lambd}')
            ax.imshow(hue_wheel_image)
            ax.axis('off')  # Turn off axis
            # Assuming the center of the hue wheel and the radius are known
            center_x, center_y, radius = 128, 128, 126
            # Define your color hues in degrees
            
            # Convert degrees to radians and plot the radii
            for i, hue in enumerate(color_hues):
                # Calculate the end point of the radius
                end_x = center_x + radius * np.cos(np.radians(hue - 90))
                end_y = center_y + radius * np.sin(np.radians(hue - 90))

                # Plot a line from the center to the edge of the hue wheel
                ax.plot([center_x, end_x], [center_y, end_y], 'w-', markersize=4)  # 'w-' specifies a white line
                #ax.plot([end_x], [end_y], color=colors[i], marker='o', markerfacecolor=colors[i], markersize=15)  # 'w-' specifies a white line
        
            os.makedirs(join(self.repo_folder, 'figures', 'color_wheels'), exist_ok=True)
            plt.savefig(join(self.repo_folder, 'figures', 'color_wheels', f'{method}_feature_{feature}_at_lambda_{lambd}.png'))
            plt.close() 
    
    def plot_sat_val_per_lambda(self, method, variations, variable, optimal_lambda=0):
        variations = variations[variations['Variable'] == variable]
        print(variations.shape)
        if variable in ['S1', 'V1']:
            fig, ax = plt.subplots(dpi=300)
            ax = sns.boxplot(x=variations['lambda'], y=variations[variable])
            ax.axvline(optimal_lambda, color=".3", dashes=(2, 2))
            ax.set_title(f'Values of {variable} at different lambdas')
            os.makedirs(join(self.repo_folder, 'figures', 'boxplot'), exist_ok=True)
            plt.savefig(join(self.repo_folder, 'figures', 'boxplot', f'{method}_feature_{variable}.png'))
            plt.close() 
        
    def order_by_hue(self, colors):
        colors_rgb = [COLOR_MAP[col] for col in colors]
        colors_h = np.array([rgb_to_hsv(rgb)[0] for rgb in colors_rgb])
        arg_hues = np.argsort(colors_h)
        colors = np.array(colors)[arg_hues]
        colors_rgb = list(np.array(colors_rgb)[arg_hues]) 
        return colors, colors_rgb   
    
    def heatmap_per_colors(self, variations, lambd, method, variable1='Color', variable2='Feature', cosine_sim=False, separation_vecs=None):
        """
        The heatmap_per_colors function takes in a dataframe of variations, the lambda value used to generate those variations, and the method used to generate them.
        It then plots a heatmap showing how many times each color was confused with another color. The confusion matrix is generated by comparing two variables: 
        the original variable (Color) and the final variable (Feature). By default these are both set as 'Color', but they can be changed if desired.
        
        :param self: Access the class attributes
        :param variations: Specify the dataframe that will be used to generate the confusion matrix
        :param lambd: Specify the lambda value for which we want to plot the confusion matrix
        :param method: Specify the method used to generate the heatmap
        :param variable1: Specify which column of the dataframe to use as the x-axis
        :param variable2: Specify the column name of the second variable to be used in the confusion matrix
        :return: A heatmap of the confusion matrix between two variables
        :doc-author: Trelent
        """
        #options: colors heatmap to show confusion between original color, final color, direction color
        # Plotting the confusion matrix
        colors1 = list(variations[variable1].unique())
        colors2 = list(variations[variable2].unique())
        colors = [color for color in self.colors_list if (color in colors2 and color in colors1)]
        colors, color_names = self.order_by_hue(colors)
        # Creating a confusion matrix
        confusion_matrix = np.zeros((len(colors), len(colors)))

        # Filling the confusion matrix
        for i, color in enumerate(colors):
            for j, target_color in enumerate(colors):
                if cosine_sim:
                    cos_sim = np.dot(separation_vecs[color],separation_vecs[target_color])/(norm(separation_vecs[color])*norm(separation_vecs[target_color]))
                    confusion_matrix[i, j] = cos_sim
                else:
                    confusion_matrix[i, j] = variations[variations[variable2] == color][variations[variable1] == target_color].shape[0]
        sns.set(font_scale=1.1)
        plt.figure(figsize=(20, 16))
        fmt = '.2f' if cosine_sim else 'd'
        g = sns.heatmap(np.array(confusion_matrix), annot=True, fmt=fmt, cmap='viridis',
                    yticklabels=colors, 
                    xticklabels=colors)
        plt.title(f"Confusion Matrix ({method} lambda {lambd})")
        for xtick, color in zip(g.get_xticklabels(), color_names):
            xtick.set_color(color)
        for ytick, color in zip(g.get_yticklabels(), color_names):
            ytick.set_color(color)
            
        plt.xlabel("Final Color" if variable1 == 'Color' else variable1)
        plt.ylabel("Direction Color" if variable2 == 'Feature' else variable2)
        plt.tight_layout()
        os.makedirs(join(self.repo_folder, 'figures', 'confusion_matrices_new'), exist_ok=True)
        plt.savefig(join(self.repo_folder, 'figures', 'confusion_matrices_new', f'{method}_features_{variable1},{variable2}_at_lambda_{lambd}.png'))
        plt.close() 
    
    

if __name__ == '__main__':          
    parser = argparse.ArgumentParser(description='Process input arguments')
    
    parser.add_argument('--annotations_file', type=str, default='../data/seeds0000-100000.pkl')
    parser.add_argument('--df_modification_vectors', type=str, default='../data/modifications_stylespace_separation_vector_Color.csv') #
    parser.add_argument('--df_separation_vectors', type=str, default='../data/interfaceGAN_separation_vector_color.csv') #
    parser.add_argument('--max_lambda', type=int, default=25)
    
    args = parser.parse_args()
    try:
        with open(args.annotations_file, 'rb') as f:
            annotations = pickle.load(f)
    except:
        annotations = None
        
        
    df_modification_vectors = pd.read_csv(args.df_modification_vectors)
    df_separation_vectors = pd.read_csv(args.df_separation_vectors)
    df_separation_vectors['Separation Vector'] = [np.array([float(x.strip('[] ')) for x in row['Separation Vector'].replace('\n', ' ').split(' ') if x.strip('[] ') != '']) for i,row in df_separation_vectors.iterrows()]
    
    disentanglemnet_eval = AttributeDependency(None, annotations, space='w')
    
    for method, group in df_modification_vectors.groupby('Method'):
        variable = list(group['Variable'].unique())[0]
        group = disentanglemnet_eval.filter_variations(group, variable)
        if 'S' in variable or 'V' in variable:
            optimal_lambda = disentanglemnet_eval.calculate_optimal_lambda(group)
            disentanglemnet_eval.plot_sat_val_per_lambda(method, group, variable, optimal_lambda)
        elif variable == 'Color':
            for feature in list(group['Feature'].unique()):
                optimal_lambda = disentanglemnet_eval.calculate_optimal_lambda(group[group['Feature'] == feature])
                # disentanglemnet_eval.plot_hues_per_lambda(group, feature, method)
            for lambd in range(1,args.max_lambda):
                disentanglemnet_eval.heatmap_per_colors(group[group['lambda'] == lambd], lambd, method, variable1='Color', variable2='Feature')
            
        elif variable == 'color':
            for lambd in range(1,args.max_lambda):
                disentanglemnet_eval.heatmap_per_colors(group[group['lambda'] == lambd], lambd, method, variable1='color', variable2='Feature')
                # disentanglemnet_eval.heatmap_per_colors(group[group['lambda'] == lambd], lambd, method, variable1='Color', variable2='Color original')
            
            df_sep_meth = df_separation_vectors[df_separation_vectors['Method'] == method] 
            separation_vecs = {k:v for k,v in zip(df_sep_meth['Feature'], df_sep_meth['Separation Vector'])}
            
            disentanglemnet_eval.heatmap_per_colors(group, 0, method, variable1='color', variable2='color', cosine_sim=True, separation_vecs=separation_vecs)
            
       